submit()
submti()
submit()
mad_libs(place="asshole", adjective="king", noun="fister")
submit()
"I"p"love"p"R!"
"I" p "love" p "R!"
'I' p 'love' p 'R!'
"I"%p%"love"%p%"R!"
swirl()
?<<-
?%<<-%
?"<<-"
swirl()
library(swirl())
swilr()
swirl()
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(plants)
head(plants, 10)
tail(plants, 15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
?sample
sample(1:6,4, replace=TRUE)
sample(1:6,4, replace=TRUE)
sample(1:30,20)
sample(1:20,10)
LETTERS
sample(LETTERS)
flips <- sample(c(0,1), 100, replace=TRUE, prob=c(0.3,0.7))
flips
sum(flips)
?rbimnom
?rbinom
rbinom(1,100, 0.7)
flips2 <- rbinom(100,100,0.7)
flips2 <- rbinom(100,1,0.7)
flips2
sum(flips2)
?rnorm()
?rnorm
rnorm(10)
rnorm(10,100,25)
?rpois
rpois(5,10)
replicate(100, rpois(5,10))
my_pois <- replicate(100, rpois(5,10))
my_pois
cm <- colMeans(my_pois)
hist(cm)
data(cars)
?cars
head(cars)
plot(cars)
?plot
?plot
plot(x= cars$speed, y= cars$dist)
plot(y= cars$speed, x= cars$dist)
plot(y= cars$speed, Speed= cars$dist)
?plot
plot(x=cars$speed, y=cars$dist)
plot(x=cars$speed, y=cars$dist, xlab="Speed")
plot(x=cars$speed, y=cars$dist, ylab="Stopping Distance")
plot(x=cars$speed, y=cars$dist, xlab= "Speed",ylab="Stopping Distance")
plot(cars, main="My Plot")
plot(cars, main="My Plot")
plot(cars, sub="My Plot Subtitle")
plot(cars, col=2)
plot(cars, xlim=c(10,15))
plot(cars, pch=2
plot(cars, pch=2)
plot(cars, pch=2)
library(mtcars)
data(mtcars)
?boxplot
boxplot(data, mpg ~ cyl)
boxplot(data, formula=mpg ~ cyl)
dsf
boxplot(data)
boxplot(mtcars, mpg ~ cyl)
boxplot(data=mtcars, formula=mpg ~ cyl)
boxplot(formula= mpg ~cyl, data=mtcars)
hist(mtcars$mpg)
?read.csv
install.packages("KernSmooth")
library(KernSmooth)
installed.packages()
library(swirl)
swirl()
size.object(cran)
object.size(cran)
mydf <- read.csv(path2csv, stringsAsFactors = FALSE)
dim(mydf)
head(mydf)
library(dplyr)
packageVersion("dplyr")
cours <- c(17,24,26,21,25,26,26,25,24,27,30,15,26,25,25,24,23,23,19,26,25,20,25,17,17)
str(cours)
mean_cours <- mean(cour)
mean_cours <- mean(cours)
mean_cours
exer <- c(0,3,2,4,2,3,7,2,4,2,2,4,0,3,5,2,3,5,4,4,4,4,2,5,6)
str(exer)
mean_exer <- mean(exer)
test <- mean(c(19,15,18,17,21,14))
test
test <- mean(c(11,8,13,11,9,8))
test
test <- mean(c(0,6,0,2,3,11))
test
cours <-c(15,24,24,19,23,24,23,20,20,24,25,11,26,25,23,23,23,21,13,23,23,18,25,17,17)
str(cours)
mean(cours)
repet <- c(0,3,2,2,4,1,4,2,4,2,2,4,0,3,5,2,3,5,4,4,4,4,2,5,6)
str(repet)
mean(repet)
tp <- c(2,0,2,2,0,2,3,3,2,3,5,4,0,0,1,1,0,2,6,3,3,2,0,0,0)
mean(tp)
library(swrirl)
library(swirl)
swirl()
library(swirl)
swirl()
cran <- tbl_df(mydf)
rm("mydf")
?tbl_df
cran
?select
select(cran, ip_id, package, country)
5:20
select(cran, r_arch:country)
select(cran, country:r_arch)
cran
select(cran, -time)
-5:20
-(5:20)
select(cran, -(x:size))
sd
select(cran, -(X:size))
filter(cran, package =="swirl")
filter(crain, r_version=="3.1.1", country=="US")
filter(cran, r_version=="3.1.1", country=="US")
?Comparison
filter(cran, r_version=="3.0.2", country=="IN")
filter(cran, r_version<="3.0.2", country=="IN")
filter(cran, country=="US" | country=="IN")
filter(cran, size > 100500, r_os=="linux-gnu")
is.na(c(3,5,NA,10))
!is.na(c(3,5,NA,10))
filter(cran, !is.na(r_version))
cran2<- select(crain, size:ip_id)
cran2<- select(cran, size:ip_id)
arrange(cran2, ip_id)
arrange(cran2, desc(ip_id))
arrange(cran2, package, ip_id
)
arrange(cran2, country, desc(r_version),ip_id)
cran3 <- select(cran, ip_id, package, size)
cran
cran3
mutate(crain3, size_mb=size/2^20)
mutate(cran3, size_mb=size/2^20)
mutate(cran3, size_mb=size/2^20, size_gb=size_mb/2^10)
mutate(cran3, correct_size= size+1000)
summarize(cran, avg_bytes=mean(size))
library(swirl)
swirl()
library(dplyr)
cran <- tbl_df(by_package)
cran <- tbl_df(mydf)
rm("mydf")
cran
?group_by
by_package<- group_by(cran, package)
by_package
summarize(by_package, mean(size))
submit()
submit()
pack_sum
quantile(pack_sum$count, probs= 0.99)
top_counts <-filter(pack_sum, count >679)
top_counts
View(top_counts)
top_counts_sorted <-arrange(top_couns, desc(count))
top_counts_sorted <-arrange(top_counts, desc(count))
View(top_counts_sorted)
quantile(pack_sum$unique, probs=0.99)
top_unique <-filter(pack_sum, unique >465)
View(top_unique)
top_unique_sorted <-arrange(top_unique, desc(unique))
View/top_unique_sorted
View(top_unique_sorted)
submit()
submit()
submit()
submit()
View(result3)
submit()
submit()
submit()
submit()
submit()
library(tidyr)
students
?gather
gather(students, sex, count, -grade)
students2
res <- gather(students2, sex_class, count)
res <- gather(students2, sex_class, count,-grade)
res
?separate
separate(data=res, col=sex_class, into=c("sex","class"))
submit()
students3
submit()
?gather
submit()
?spread
submit()
submit()
submit()
skip()
library(readyr)
library(readr)
parse_number("class5")
skip()
students4
submit()
submit()
submit()
submit()
submit()
passed
failed
mutate(passed, status = "passed")
passed <- mutate(passed, status = "passed")
failed <- failed %>% mutate(failed, status="failed")
failed <- failed %>% mutate(failed, status="failed")
sdf
failed <- casc
failed <-1
failed <- failed %>% mutate(status ="failed")
libary(swirl)
library(swirl)
swirl()
failed <- failed %>% mutate(status="failed")
bind_rows(passed, failed)
sat
?separate
submit()
submit()
q()
?Rprofile
?lm
?mtcars
str(mtcars)
data("mtcars", package = "datasets")
is.data.frame(mtcars) #check if data frame object
names(mtcars)
summary(mtcars)
head(mtcars)
cor(mtcars[,c("mpg","hp","wt")])
?plot
pairs(mtcars[,c("mpg","hp","wt")], main = "mtcars data")
pairs(mtcars[, c("mpg", "hp", "wt")], panel = function(x, y){
abline(lm(y ~ x))
lines(lowess(x, y), lty = 2, col = 2)
points(x, y, pch = 20)
legend(x = "topright", legend = paste("Cor = ", round(cor(x, y), 2)), bty = "n")
})
#Design matrix
wt <- mtcars$wt
X <- cbind(1, wt)
mpg <- mtcars$mpg
#OLS estimates
XtXinv <- solve(crossprod(X))
beta_hat <- c(XtXinv %*% t(X) %*% mpg)
#Form orthogonal projection matrix
Hmat <- X %*% XtXinv %*% t(X)
#Create residuals and fitted values
fitted <- Hmat %*% mpg
res <- mpg - fitted
fitted <- Hmat %*% mpg
#Variance estimate and standard errors
s2 <- sum(res^2) / (length(res) - ncol(X))
std_err <- sqrt(diag(s2 * XtXinv))
plot(mpg ~ wt, xlab = "weight (1000 lbs)", ylab = "miles/US gallon",
main = "Fuel consumption of automobiles, 1974 Motor Trend", data = mtcars,
bty = "l", pch = 20, ylim = c(0, 35), xlim = c(0, 6))
#Line of best linear fit
abline(a = beta_hat[1], b = beta_hat[2], col = "blue", lwd = 2)
#Residuals are vertical distance from line to
for(i in 1:nrow(X)){
segments(x0 = wt[i], y0 = fitted[i], y1 = fitted[i] + res[i], col = 2)
}
baba <- function(x){x}
baba(x)
baba(1)
setwd("C:/Users/Ivan/Desktop/Data-Analysis-Project")
View(baba)
q()
##install packages ggplot2,car,GGally, knitr
library(ggplot2)
library(car)
library(knitr)
library(GGally)
prostate <- read.table("http://sma.epfl.ch/~lbelzile/math341/prostate.dat", header = TRUE)
attach(prostate)
##Exploratory data analysis
str(prostate)
apply(prostate, 2, range)
print(GGally::ggpairs(prostate[,-c(5,7)]), progress = FALSE)
##lpsa has linear relationship with lcavol, (less)lweight, lcp, rests seems uncorrelated
##collinearity between lcavol-lcp
##no need for transformations
##default value observed before taking log need to clean
gleason <- factor(gleason, ordered=FALSE)
svi <- factor(svi, ordered=FALSE)
##Fit full model
full_model <- lm(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45)
summary_fm <- summary(full_model)
knitr::kable(coef(summary_fm), digits = 3)
##have intercept table, interpret t values
##strong evidence against the hypothesis that lcavol, lweight, svi souldn't be included
##pgg45 close to 0
##perform backward selection
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + pgg45), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi + pgg45), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + lbph + svi), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + svi), test = "F")
##forward selection:
##end up with same model
##add_interactions
backward_selection_model<- lm(lpsa ~ lcavol + lweight + svi)
interaction1_model<- lm(lpsa ~ lcavol + lweight + svi + lcavol:svi + lweight:svi)
interaction2_model<- lm(lpsa ~ lcavol + lweight + svi + lcavol:svi)
interaction3_model<- lm(lpsa ~ lcavol + lweight + svi + lweight:svi)
##perform model selection on models built
##CV
AIC(full_model)
AIC(backward_selection_model)
AIC(interaction1_model)
AIC(interaction2_model)
AIC(interaction3_model)
BIC(full_model)
BIC(backward_selection_model)
BIC(interaction1_model)
BIC(interaction2_model)
BIC(interaction3_model)
summary(full_model)$adj.r.squared
summary(backward_selection_model)$adj.r.squared
summary(interaction1_model)$adj.r.squared
summary(interaction2_model)$adj.r.squared
summary(interaction3_model)$adj.r.squared
##cross validation
##select backward_selection_model
##diagnostics on final model
##do plot residuals against each covariates
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 0.5))
bl <- scales::alpha("black", 0.5) #semi-transparent black
n <- nrow(prostate)
#Student Q-Q plot
qqPlot(backward_selection_model, simulate = 1999, envelope = TRUE,
ylab = "Externally studentized residuals",
xlab = "Theoretical student quantiles",
pch = 20, col = bl)
#Residuals vs fitted values
residualPlot(backward_selection_model, type = "rstudent", quadratic = FALSE,
pch = 20, ylab = "Externally studentized residuals")
#Cook distance hat values
plot(cooks.distance(backward_selection_model), col = bl, pch = 20, ylab = "Cook's distances")
abline(h = 8/(n-2*length(coef(backward_selection_model))), col = 2)
influencePlot(backward_selection_model)
##colinearity
vif(backward_selection_model)
M <- model.matrix(backward_selection_model)
kappa(M, exact = TRUE, norm='2')
##install packages ggplot2,car,GGally, knitr
library(ggplot2)
library(car)
library(knitr)
library(GGally)
prostate <- read.table("http://sma.epfl.ch/~lbelzile/math341/prostate.dat", header = TRUE)
attach(prostate)
##Exploratory data analysis
str(prostate)
apply(prostate, 2, range)
print(GGally::ggpairs(prostate[,-c(5,7)]), progress = FALSE)
##lpsa has linear relationship with lcavol, (less)lweight, lcp, rests seems uncorrelated
##collinearity between lcavol-lcp
##no need for transformations
##default value observed before taking log need to clean
gleason <- factor(gleason, ordered=FALSE)
svi <- factor(svi, ordered=FALSE)
##Fit full model
full_model <- lm(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45)
summary_fm <- summary(full_model)
knitr::kable(coef(summary_fm), digits = 3)
##have intercept table, interpret t values
##strong evidence against the hypothesis that lcavol, lweight, svi souldn't be included
##pgg45 close to 0
##perform backward selection
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + pgg45), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi + pgg45), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + age + lbph + svi), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + lbph + svi), test = "F")
drop1(lm(lpsa ~ lcavol + lweight + svi), test = "F")
##forward selection:
##end up with same model
##add_interactions
backward_selection_model<- lm(lpsa ~ lcavol + lweight + svi)
interaction1_model<- lm(lpsa ~ lcavol + lweight + svi + lcavol:svi + lweight:svi)
interaction2_model<- lm(lpsa ~ lcavol + lweight + svi + lcavol:svi)
interaction3_model<- lm(lpsa ~ lcavol + lweight + svi + lweight:svi)
##perform model selection on models built
##CV
AIC(full_model)
AIC(backward_selection_model)
AIC(interaction1_model)
AIC(interaction2_model)
AIC(interaction3_model)
BIC(full_model)
BIC(backward_selection_model)
BIC(interaction1_model)
BIC(interaction2_model)
BIC(interaction3_model)
summary(full_model)$adj.r.squared
summary(backward_selection_model)$adj.r.squared
summary(interaction1_model)$adj.r.squared
summary(interaction2_model)$adj.r.squared
summary(interaction3_model)$adj.r.squared
##cross validation
##select backward_selection_model
##diagnostics on final model
##do plot residuals against each covariates
par(mfrow = c(2, 2), mar = c(5, 5, 1.5, 0.5))
bl <- scales::alpha("black", 0.5) #semi-transparent black
n <- nrow(prostate)
#Student Q-Q plot
qqPlot(backward_selection_model, simulate = 1999, envelope = TRUE,
ylab = "Externally studentized residuals",
xlab = "Theoretical student quantiles",
pch = 20, col = bl)
#Residuals vs fitted values
residualPlot(backward_selection_model, type = "rstudent", quadratic = FALSE,
pch = 20, ylab = "Externally studentized residuals")
#Cook distance hat values
plot(cooks.distance(backward_selection_model), col = bl, pch = 20, ylab = "Cook's distances")
abline(h = 8/(n-2*length(coef(backward_selection_model))), col = 2)
influencePlot(backward_selection_model)
##colinearity
vif(backward_selection_model)
M <- model.matrix(backward_selection_model)
kappa(M, exact = TRUE, norm='2')
K <- model.matrix(interaction1_model)
k
str(K)
remove(K)
K <- 10
#Manually perform cross fold validation
KfoldCV <- function(fitted.mod, K, ...){
data <- model.matrix(fitted.mod) #design matrix
y <- fitted.mod$model[,1] #response
n <- nrow(data)
#Shuffle the indices
inds <- sample.int(n = n, size = n, replace = FALSE)
#Split into K groups of ~ equal size (from https://stackoverflow.com/a/16275428)
form_group <- function(x, n){ split(x, cut(seq_along(x), n, labels = FALSE)) }
groups <- form_group(inds, K)
#Obtain prediction from K-folds
preds <- rep(NA, n)
for(j in 1:K){
preds[groups[[j]]] <- data[groups[[j]],] %*% lm(y[-groups[[j]]] ~ -1 + data[-groups[[j]],])$coef
}
#Compute prediction error
crossprod(preds - y)[1,1]
}
round(c("full model" = median(replicate(KfoldCV(fitted.mod = full_model, K = K), n = 100)),
"backward selection model " = median(replicate(KfoldCV(fitted.mod = backward_selection_model, K = K), n = 100)),
"interaction1 model" = median(replicate(KfoldCV(fitted.mod = interaction1_model, K = K), n = 100)),
"interaction2 model" = median(replicate(KfoldCV(fitted.mod = interaction2_model, K = K), n = 100)),
"interaction3 model" = median(replicate(KfoldCV(fitted.mod = interaction3_model, K = K), n = 100))),
digits = 2)
install.package("leaps")
install.packages("leaps")
library(leaps)
leaps=regsubsets(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45,data=prostate, nbest=10)
plot(leaps, scale="bic")
plot(leaps, scale="bic")
plot(leaps, scale="bic")
leaps=regsubsets(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45,data=prostate, nbest=10)
?regsubsets
leaps=regsubsets(lpsa ~ lcavol + lweight + age + lbph + svi + lcp + gleason + pgg45,data=prostate, nbest=1)
plot(leaps, scale="bic")
plot(leaps, scale="aic")
?regsubsets
plot(leaps, scale="cp")
plot(leaps, scale="bic")
summary(leaps)
BIC(backward_selection_model)
BIC(full_model)
